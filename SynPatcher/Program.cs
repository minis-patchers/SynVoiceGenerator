using Mutagen.Bethesda;
using Mutagen.Bethesda.Json;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Newtonsoft.Json;
using Noggog;
using Noggog.StructuredStrings;
using System.Data;
using System.Diagnostics;
using System.IO.Compression;
using System.Text;
using System.Text.RegularExpressions;

namespace SynPatcher;
public static class Program
{
    public static async Task DownloadFileAsync(string fileUrl, string destinationPath)
    {
        try
        {
            HttpClient dlclient = new();
            using var fileStream = new FileStream(destinationPath, FileMode.Create, FileAccess.Write, FileShare.None);
            var resp = await dlclient.GetStreamAsync(fileUrl);
            await resp.CopyToAsync(fileStream);
            Console.WriteLine($"Downloaded: {destinationPath}");
        }
        catch (HttpRequestException ex)
        {
            Console.WriteLine($"HTTP error: {ex.Message}");
        }
        catch (IOException ex)
        {
            Console.WriteLine($"File I/O error: {ex.Message}");
        }
    }
    static List<LineTracker> lines = [];
    static readonly HashSet<string> generatedText = [];
    static Lazy<ElevenLabs> api = new();
    public static ElevenLabs APIInfo => api.Value;
    static readonly HttpClient client = new();
    static string EDFP = string.Empty;
    static string CKTools = string.Empty;
    public static async Task<int> Main(string[] args)
    {
        return await SynthesisPipeline.Instance.SetAutogeneratedSettings("ElevenLabs", "elevenlabs.json", out api).SetTypicalOpen(GameRelease.SkyrimSE, "Labs.esp").AddPatch<ISkyrimMod, ISkyrimModGetter>(Patch).Run(args);
    }
    static void Patch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        JsonSerializerSettings settings = new();
        settings.AddMutagenConverters();
        settings.Formatting = Formatting.Indented;
        EDFP = state.ExtraSettingsDataPath ?? string.Empty;
        var parent = Directory.GetParent(state.DataFolderPath);
        CKTools = Path.Join(parent?.FullName, "Tools");
        Directory.CreateDirectory(Path.Join(state.ExtraSettingsDataPath, "tmp"));
        if (!File.Exists(Path.Join(state.ExtraSettingsDataPath, "ffmpeg.exe")))
        {
            if (!File.Exists(Path.Join(state.ExtraSettingsDataPath, "tmp", "FFMPEG.zip")))
            {
                DownloadFileAsync("https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-n7.1-latest-win64-gpl-7.1.zip", Path.Join(state.ExtraSettingsDataPath, "tmp", "FFMPEG.zip")).Wait();
                using var zip = ZipFile.OpenRead(Path.Join(state.ExtraSettingsDataPath, "tmp", "FFMPEG.zip"));
                var ent = zip.Entries.Where(x => x.Name == "ffmpeg.exe").First();
                ent.ExtractToFile(Path.Join(state.ExtraSettingsDataPath, "ffmpeg.exe"));
            }
        }
        if (!File.Exists(Path.Join(state.ExtraSettingsDataPath, "FaceFXWrapper.exe")))
        {
            DownloadFileAsync("https://github.com/Nukem9/FaceFXWrapper/releases/download/0.41/FaceFXWrapper.0.41.zip", Path.Join(state.ExtraSettingsDataPath, "tmp", "facefx.zip")).Wait();
            using var zip = ZipFile.OpenRead(Path.Join(state.ExtraSettingsDataPath, "tmp", "facefx.zip"));
            var ffxw = zip.Entries.Where(x => x.Name == "FaceFXWrapper.exe").First();
            ffxw.ExtractToFile(Path.Join(state.ExtraSettingsDataPath, "FaceFXWrapper.exe"));
        }
        if (!File.Exists("FonixData.cdf"))
        {
            File.Copy(Path.Join(CKTools, "LipGen", "LipGenerator", "FonixData.cdf"), "FonixData.cdf");
        }
        if (File.Exists(Path.Join(EDFP, "map.json")))
        {
            HashSet<FormKey> seenForms = [];
            lines = JsonConvert.DeserializeObject<List<LineTracker>>(File.ReadAllText(Path.Join(EDFP, "map.json")), settings) ?? [];
            HashSet<LineTracker> empties = [];
            foreach (var lin in lines)
            {
                HashSet<FormKey> rem = [];
                foreach (var id in lin.forms)
                {
                    if (!seenForms.Add(id))
                    {
                        rem.Add(id);
                    }
                }
                if (rem.Count != 0)
                {
                    Log($"Deduping {string.Join(',', rem.Select(x => x.ToString()))}", LogMode.NORMAL);
                    lin.forms.Remove(rem);
                }
                if (lin.forms.Count == 0)
                {
                    empties.Add(lin);
                }
            }
            Log($"Removing {empties.Count} empty lines", LogMode.NORMAL);
            lines.Remove(empties);
        }
        Directory.CreateDirectory($"{EDFP}/VGOutput/mp3/");
        Directory.CreateDirectory($"{EDFP}/VGOutput/wav/");
        Directory.CreateDirectory($"{EDFP}/VGOutput/wav/");
        Directory.CreateDirectory($"{EDFP}/VGOutput/lip/");
        Directory.CreateDirectory($"{EDFP}/VGOutput/xwm/");
        Directory.CreateDirectory($"{EDFP}/VGOutput/fuz/");
        client.DefaultRequestHeaders.Add("xi-api-key", APIInfo.key);
        client.BaseAddress = new Uri($"https://api.elevenlabs.io");
        foreach (var (Name, FormKey) in state.LoadOrder.PriorityOrder.DialogTopic().WinningOverrides().Where(x => $"{x.Name}" != x.EditorID && x.Category == DialogTopic.CategoryEnum.Topic).Where(x => !$"{x.Name}".IsNullOrEmpty() && $"{x.Name}" != $"{x.EditorID}").Select(x => (x.Name, x.FormKey)))
        {
            var nam = $"{Name}";
            nam = REG.HiddenFN.Replace(nam, "").Trim();
            nam = REG.HiddenFN2.Replace(nam, "").Trim();
            if (nam.IsNullOrEmpty()) continue;
            //Ensure a completely unique GUID
            var line = lines.FirstOrDefault(x => x?.forms.Any(fk => state.LinkCache.TryResolve<IDialogTopicGetter>(fk, out var output, ResolveTarget.Winner) && output.Name?.ToString() == nam) ?? false, null);
            if (line != null)
            {
                Log($"Duplicate attempted to generating, adding formkey to existing line", LogMode.NORMAL);
                line.forms.Add(FormKey);
                continue;
            }
            var guid = Guid.NewGuid().ToString().ToUpper();
            while (lines.Any(x => x.guid == $"{guid}") || File.Exists(Path.Join(EDFP, "VGOutput", "fuz", $"{guid}.fuz")))
            {
                Console.WriteLine("Regenerating identical guid");
                guid = Guid.NewGuid().ToString().ToUpper();
            }
            //Basic Text Line
            if (!nam.Contains('<') && !nam.Contains('>') && !(nam.StartsWith('(') && nam.EndsWith(')')) && !(nam.StartsWith('[') && !nam.EndsWith(']')) && !(nam.EndsWith('*') && nam.StartsWith('*')) && !nam.Contains('_') && nam.Trim() != "..." && !nam.StartsWith('$'))
            {
                var vl = new LineTracker()
                {
                    forms = [FormKey],
                    guid = $"{guid}",
                    splen = 0,
                };
                TryGen(vl, nam);
            }
            //Player alias
            else if (nam.Contains("<Alias=Player>"))
            {
                foreach (var gpn in APIInfo.player_names)
                {
                    var gn = nam.Replace("<Alias=Player>", gpn);
                    var vl = new LineTracker()
                    {
                        forms = [FormKey],
                        guid = $"{guid}",
                        splen = 0,
                    };
                    TryGen(vl, gn);
                }
            }
            //Other (Unhandled)
            else
            {
                if (nam.Trim() != "...")
                    Log($"SGen \"{nam}\"", LogMode.NORMAL);
            }
        }
        File.WriteAllText(Path.Join(EDFP, "map.json"), JsonConvert.SerializeObject(lines, settings));
        foreach (var line in lines)
        {
            if (File.Exists($"VGOutput/fuz/{line.guid}.fuz"))
            {
                foreach (var id in line.forms)
                {
                    var fp = Path.Join(state.DataFolderPath, "Sound", "VPC", "DefaultVoice", id.ModKey.ToString(), $"{id.IDString()}.fuz");
                    var jso = Path.Join(state.DataFolderPath, "Sound", "VPC", "DefaultVoice", id.ModKey.ToString(), $"{id.IDString()}.json");
                    File.Copy($"{EDFP}/VGOutput/fuz/{line.guid}.fuz", fp, true);
                    File.WriteAllText(jso, JsonConvert.SerializeObject(new VoiceMeta() { splen = line.splen }));
                }
            }
        }
    }

    static void TryGen(LineTracker line, string text)
    {
        if (!generatedText.Contains(text))
        {
            if (!APIInfo.dry_run)
            {
                try
                {
                    GenerateLive(line, text);
                    lines.Add(line);
                }
                catch (Exception ex)
                {
                    Log($"{ex.Message}", LogMode.NORMAL);
                    APIInfo.dry_run = true;
                }
            }
            else
            {
                GenerateDry(text);
            }
            generatedText.Add(text);
        }
    }

    static void Log(string lt, LogMode md)
    {
        if (APIInfo.log_mode >= md)
        {
            Console.WriteLine(lt);
        }
    }
    static void GenerateDry(string og_txt)
    {
        Log($"DRY {og_txt}", LogMode.DEBUG);
    }
    static void GenerateLive(LineTracker data, string text)
    {
        var mp3name = Path.GetFullPath($"{EDFP}/VGOutput/mp3/{data.guid}.mp3");
        var wavname = Path.GetFullPath($"{EDFP}/VGOutput/wav/{data.guid}.wav");
        var rwavnam = Path.GetFullPath($"{EDFP}/VGOutput/wav/{data.guid}.resamp.wav");
        var lipname = Path.GetFullPath($"{EDFP}/VGOutput/lip/{data.guid}.lip");
        var xwmname = Path.GetFullPath($"{EDFP}/VGOutput/xwm/{data.guid}.xwm");
        var fuzname = Path.GetFullPath($"{EDFP}/VGOutput/fuz/{data.guid}.fuz");
        if (!File.Exists(mp3name) && !File.Exists(fuzname))
        {
            Log($"Generating: {text}", LogMode.NORMAL);
            StringContent stringContent = new(JsonConvert.SerializeObject(new Request(text, APIInfo)), Encoding.UTF8, "application/json");
            var cli = client.PostAsync($"/v1/text-to-speech/{APIInfo.voice_id}?output_format=mp3_44100_128", stringContent);
            cli.Wait();
            if (cli.Result.IsSuccessStatusCode)
            {
                var file = File.OpenWrite(mp3name);
                cli.Result.Content.CopyTo(file, null, CancellationToken.None);
                file.Close();
            }
            else
            {
                Log($"error: {cli.Result.StatusCode}", LogMode.NORMAL);
                throw new Exception("Out of requests");
            }
        }
        if (!File.Exists(fuzname) && File.Exists(mp3name))
        {
            data.splen = Exts.GetMp3Duration(mp3name);
            if (!File.Exists(wavname))
            {
                Process.Start($"{EDFP}/ffmpeg.exe", $"-i \"{mp3name}\" -ac 1 \"{wavname}\"").WaitForExit();
            }
            Process.Start($"{EDFP}/FaceFXWrapper.exe", $"Skyrim USEnglish FonixData.cdf \"{wavname}\" \"{rwavnam}\" \"{lipname}\" \"{text.Replace("\"", "\\\"")}\"").WaitForExit();
            Process.Start($"{EDFP}/xWMAEncode.exe", $"\"{wavname}\" \"{xwmname}\"").WaitForExit();
            Process.Start($"{EDFP}/BmlFuzEncode.exe", $"\"{fuzname}\" \"{xwmname}\" \"{lipname}\"").WaitForExit();
            Log($"Generated {text}", LogMode.NORMAL);
        }
        else
        {
            Log($"Skipping {text}", LogMode.NORMAL);
        }
    }
}

public static partial class REG
{
    [GeneratedRegex("(\\s?\\(.*\\)\\s?)")]
    private static partial Regex Hidden();
    public static Regex HiddenFN => Hidden();
    [GeneratedRegex("(\\s?\\[.*\\]\\s?)")]
    private static partial Regex Hidden2();
    public static Regex HiddenFN2 => Hidden2();
}