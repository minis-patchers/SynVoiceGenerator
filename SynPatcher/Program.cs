using Mutagen.Bethesda;
using Mutagen.Bethesda.Json;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Newtonsoft.Json;
using Noggog;
using System.Data;
using System.Diagnostics;
using System.IO.Compression;
using System.Text;
using System.Text.RegularExpressions;

namespace SynPatcher;
public static class Program
{
    public static async Task DownloadFileAsync(string fileUrl, string destinationPath)
    {
        try
        {
            HttpClient dlclient = new();
            using var fileStream = new FileStream(destinationPath, FileMode.Create, FileAccess.Write, FileShare.None);
            var resp = await dlclient.GetStreamAsync(fileUrl);
            await resp.CopyToAsync(fileStream);
            Console.WriteLine($"Downloaded: {destinationPath}");
        }
        catch (HttpRequestException ex)
        {
            Console.WriteLine($"HTTP error: {ex.Message}");
        }
        catch (IOException ex)
        {
            Console.WriteLine($"File I/O error: {ex.Message}");
        }
    }
    static List<VoiceLine> lines = [];
    static readonly HashSet<string> generatedText = [];
    static Lazy<ElevenLabs> api = new();
    public static ElevenLabs APIInfo => api.Value;
    static readonly HttpClient client = new();
    static string DFP = string.Empty;
    static string EDFP = string.Empty;
    static string CKTools = string.Empty;
    public static async Task<int> Main(string[] args)
    {
        return await SynthesisPipeline.Instance.SetAutogeneratedSettings("ElevenLabs", "elevenlabs.json", out api).SetTypicalOpen(GameRelease.SkyrimSE, "Labs.esp").AddPatch<ISkyrimMod, ISkyrimModGetter>(Patch).Run(args);
    }
    static void Patch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        JsonSerializerSettings settings = new();
        settings.AddMutagenConverters();
        settings.Formatting = Formatting.Indented;
        var parent = Directory.GetParent(state.DataFolderPath);
        CKTools = Path.Join(parent?.FullName, "Tools");
        DFP = state.DataFolderPath;
        Directory.CreateDirectory(Path.Join(state.ExtraSettingsDataPath, "tmp"));
        Directory.CreateDirectory(Path.Join(state.ExtraSettingsDataPath, "Prior"));
        if (!File.Exists(Path.Join(state.ExtraSettingsDataPath, "ffmpeg.exe")))
        {
            if (!File.Exists(Path.Join(state.ExtraSettingsDataPath, "tmp", "FFMPEG.zip")))
            {
                DownloadFileAsync("https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-n7.1-latest-win64-gpl-7.1.zip", Path.Join(state.ExtraSettingsDataPath, "tmp", "FFMPEG.zip")).Wait();
                using var zip = ZipFile.OpenRead(Path.Join(state.ExtraSettingsDataPath, "tmp", "FFMPEG.zip"));
                var ent = zip.Entries.Where(x => x.Name == "ffmpeg.exe").First();
                ent.ExtractToFile(Path.Join(state.ExtraSettingsDataPath, "ffmpeg.exe"));
            }
        }
        if (!File.Exists(Path.Join(state.ExtraSettingsDataPath, "FaceFXWrapper.exe")))
        {
            DownloadFileAsync("https://github.com/Nukem9/FaceFXWrapper/releases/download/0.41/FaceFXWrapper.0.41.zip", Path.Join(state.ExtraSettingsDataPath, "tmp", "facefx.zip")).Wait();
            using var zip = ZipFile.OpenRead(Path.Join(state.ExtraSettingsDataPath, "tmp", "facefx.zip"));
            var ffxw = zip.Entries.Where(x => x.Name == "FaceFXWrapper.exe").First();
            ffxw.ExtractToFile(Path.Join(state.ExtraSettingsDataPath, "FaceFXWrapper.exe"));
        }
        if (!File.Exists("FonixData.cdf"))
        {
            File.Copy(Path.Join(CKTools, "LipGen", "LipGenerator", "FonixData.cdf"), "FonixData.cdf");
        }
        if (File.Exists(Path.Join(state.DataFolderPath, "SKSE", "VPC", "map.json")))
        {
            lines = JsonConvert.DeserializeObject<List<VoiceLine>>(File.ReadAllText(Path.Join(state.DataFolderPath, "SKSE", "VPC", "map.json")), settings) ?? [];
        }
        Directory.CreateDirectory($"VGOutput/mp3/");
        Directory.CreateDirectory($"VGOutput/wav/");
        Directory.CreateDirectory($"VGOutput/wav/");
        Directory.CreateDirectory($"VGOutput/lip/");
        Directory.CreateDirectory($"VGOutput/xwm/");
        EDFP = state.ExtraSettingsDataPath ?? "";
        client.DefaultRequestHeaders.Add("xi-api-key", APIInfo.key);
        client.BaseAddress = new Uri($"https://api.elevenlabs.io");
        foreach (var (Name, FormKey) in state.LoadOrder.PriorityOrder.DialogTopic().WinningOverrides().Where(x => $"{x.Name}" != x.EditorID && x.Category == DialogTopic.CategoryEnum.Topic).Where(x => !$"{x.Name}".IsNullOrEmpty() && $"{x.Name}" != $"{x.EditorID}").Select(x => (x.Name, x.FormKey)))
        {
            var nam = $"{Name}";
            nam = REG.HiddenFN.Replace(nam, "").Trim();
            nam = REG.HiddenFN2.Replace(nam, "").Trim();
            if (nam.IsNullOrEmpty()) continue;
            //Ensure a completely unique GUID
            var line = lines.FirstOrDefault(x => x?.forms.Any(fk => state.LinkCache.TryResolve<IDialogTopicGetter>(fk, out var output, ResolveTarget.Winner) && output.Name?.ToString() == nam) ?? false, null);
            if (line != null)
            {
                line.forms.Add(FormKey);
                continue;
            }
            var guid = Guid.NewGuid().ToString().ToUpper();
            while (lines.Any(x => x.guid == $"{guid}"))
            {
                Console.WriteLine("Regenerating identical guid");
                guid = Guid.NewGuid().ToString().ToUpper();
            }
            //Basic Text Line
            if (!nam.Contains('<') && !nam.Contains('>') && !(nam.StartsWith('(') && nam.EndsWith(')')) && !(nam.StartsWith('[') && !nam.EndsWith(']')) && !(nam.EndsWith('*') && nam.StartsWith('*')) && !nam.Contains('_') && nam.Trim() != "..." && !nam.StartsWith('$'))
            {
                var vl = new VoiceLine()
                {
                    forms = [FormKey],
                    guid = $"{guid}",
                    splen = 0,
                };
                TryGen(vl, nam);
            }
            //Player alias
            else if (nam.Contains("<Alias=Player>"))
            {
                foreach (var gpn in APIInfo.player_names)
                {
                    var gn = nam.Replace("<Alias=Player>", gpn);
                    var vl = new VoiceLine()
                    {
                        forms = [FormKey],
                        guid = $"{guid}",
                        splen = 0,
                    };
                    TryGen(vl, gn);
                }
            }
            //Other (Unhandled)
            else
            {
                if (nam.Trim() != "...")
                    Log($"SGen \"{nam}\"", LogMode.NORMAL);
            }
        }
        File.WriteAllText(Path.Join(state.DataFolderPath, "SKSE", "VPC", "map.json"), JsonConvert.SerializeObject(lines, settings));
    }

    static void TryGen(VoiceLine line, string text)
    {
        if (!generatedText.Contains(text))
        {
            if (!APIInfo.dry_run)
            {
                try
                {
                    GenerateLive(line, text);
                    lines.Add(line);
                }
                catch (Exception ex)
                {
                    Log($"{ex.Message}", LogMode.NORMAL);
                    APIInfo.dry_run = true;
                }
            }
            else
            {
                GenerateDry(text);
            }
            generatedText.Add(text);
        }
    }

    static void Log(string lt, LogMode md)
    {
        if (APIInfo.log_mode >= md)
        {
            Console.WriteLine(lt);
        }
    }
    static void GenerateDry(string og_txt)
    {
        Log($"DRY {og_txt}", LogMode.DEBUG);
    }
    static void GenerateLive(VoiceLine data, string text)
    {
        var mp3name = Path.GetFullPath($"VGOutput/mp3/{data.guid}.mp3");
        var wavname = Path.GetFullPath($"VGOutput/wav/{data.guid}.wav");
        var rwavnam = Path.GetFullPath($"VGOutput/wav/{data.guid}.resamp.wav");
        var lipname = Path.GetFullPath($"VGOutput/lip/{data.guid}.lip");
        var xwmname = Path.GetFullPath($"VGOutput/xwm/{data.guid}.xwm");
        var fuzname = Path.GetFullPath(Path.Join(DFP, "Sound", "VPC", "DefaultVoice", $"{data.guid}.fuz"));
        if (!File.Exists(mp3name) && !File.Exists(fuzname))
        {
            Log($"Generating: {text}", LogMode.NORMAL);
            StringContent stringContent = new(JsonConvert.SerializeObject(new Request(text, APIInfo)), Encoding.UTF8, "application/json");
            var cli = client.PostAsync($"/v1/text-to-speech/{APIInfo.voice_id}?output_format=mp3_44100_128", stringContent);
            cli.Wait();
            if (cli.Result.IsSuccessStatusCode)
            {
                var file = File.OpenWrite(mp3name);
                cli.Result.Content.CopyTo(file, null, CancellationToken.None);
                file.Close();
            }
            else
            {
                Log($"error: {cli.Result.StatusCode}", LogMode.NORMAL);
                throw new Exception("Out of requests");
            }
        }
        if (!File.Exists(fuzname) && File.Exists(mp3name))
        {
            data.splen = Exts.GetMp3Duration(mp3name);
            if (!File.Exists(wavname))
            {
                Process.Start($"{EDFP}/ffmpeg.exe", $"-i \"{mp3name}\" -ac 1 \"{wavname}\"").WaitForExit();
            }
            Process.Start($"{EDFP}/FaceFXWrapper.exe", $"Skyrim USEnglish FonixData.cdf \"{wavname}\" \"{rwavnam}\" \"{lipname}\" \"{text.Replace("\"", "\\\"")}\"").WaitForExit();
            Process.Start($"{EDFP}/xWMAEncode.exe", $"\"{wavname}\" \"{xwmname}\"").WaitForExit();
            Process.Start($"{EDFP}/BmlFuzEncode.exe", $"\"{fuzname}\" \"{xwmname}\" \"{lipname}\"").WaitForExit();
            Log($"Generated {text}", LogMode.NORMAL);
        }
        else
        {
            Log($"Skipping {text}", LogMode.NORMAL);
        }
    }
}

public static partial class REG
{
    [GeneratedRegex("(\\s?\\(.*\\)\\s?)")]
    private static partial Regex Hidden();
    public static Regex HiddenFN => Hidden();
    [GeneratedRegex("(\\s?\\[.*\\]\\s?)")]
    private static partial Regex Hidden2();
    public static Regex HiddenFN2 => Hidden2();
}