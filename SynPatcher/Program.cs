using Mutagen.Bethesda;
using Mutagen.Bethesda.Json;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Newtonsoft.Json;
using Noggog;
using System.Data;
using System.Diagnostics;
using System.IO.Compression;
using System.Text;
using System.Text.RegularExpressions;

namespace SynPatcher;
public static class Program
{
    public static IEnumerable<(HashSet<string>, string)> GenerateTemplatedCartesianProduct(
        this Dictionary<string, HashSet<string>> data,
        string template)
    {
        // Start with a single empty dictionary to represent the initial state
        IEnumerable<Dictionary<string, string>> combinations = [[]];

        // Iterate through each key-value pair in the input dictionary
        foreach (var entry in data)
        {
            // For each existing combination, create new combinations by adding each value from the current list
            combinations = combinations.SelectMany(
                existingCombination => entry.Value.Select(
                    value =>
                    {
                        var newCombination = new Dictionary<string, string>(existingCombination);
                        newCombination[entry.Key] = value;
                        return newCombination;
                    }));
        }

        // Now, format each generated combination into the template string
        foreach (var combination in combinations)
        {
            HashSet<string> vals = [];
            string formattedString = template;
            foreach (var kvp in combination)
            {
                // Replace placeholders in the template with the corresponding values
                vals.Add(kvp.Value);
                formattedString = formattedString.Replace($"<{kvp.Key}>", kvp.Value);
            }
            yield return (vals, formattedString);
        }
    }
    public static async Task DownloadFileAsync(string fileUrl, string destinationPath)
    {
        try
        {
            HttpClient dlclient = new();
            using var fileStream = new FileStream(destinationPath, FileMode.Create, FileAccess.Write, FileShare.None);
            var resp = await dlclient.GetStreamAsync(fileUrl);
            await resp.CopyToAsync(fileStream);
            Console.WriteLine($"Downloaded: {destinationPath}");
        }
        catch (HttpRequestException ex)
        {
            Console.WriteLine($"HTTP error: {ex.Message}");
        }
        catch (IOException ex)
        {
            Console.WriteLine($"File I/O error: {ex.Message}");
        }
    }
    static HashSet<LineTracker> lines = [];
    static Lazy<ElevenLabs> api = new();
    public static ElevenLabs APIInfo => api.Value;
    static readonly HttpClient client = new();
    static string EDFP = string.Empty;
    static string CKTools = string.Empty;
    public static async Task<int> Main(string[] args)
    {
        return await SynthesisPipeline.Instance.SetAutogeneratedSettings("ElevenLabs", "elevenlabs.json", out api).SetTypicalOpen(GameRelease.SkyrimSE, "Labs.esp").AddPatch<ISkyrimMod, ISkyrimModGetter>(Patch).Run(args);
    }
    static void Patch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        JsonSerializerSettings settings = new();
        settings.AddMutagenConverters();
        settings.Formatting = Formatting.Indented;
        EDFP = state.ExtraSettingsDataPath ?? string.Empty;
        var parent = Directory.GetParent(state.DataFolderPath);
        CKTools = Path.Join(parent?.FullName, "Tools");
        Directory.CreateDirectory(Path.Join(state.ExtraSettingsDataPath, "tmp"));
        if (!File.Exists(Path.Join(state.ExtraSettingsDataPath, "ffmpeg.exe")))
        {
            if (!File.Exists(Path.Join(state.ExtraSettingsDataPath, "tmp", "FFMPEG.zip")))
            {
                DownloadFileAsync("https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-n7.1-latest-win64-gpl-7.1.zip", Path.Join(state.ExtraSettingsDataPath, "tmp", "FFMPEG.zip")).Wait();
                using var zip = ZipFile.OpenRead(Path.Join(state.ExtraSettingsDataPath, "tmp", "FFMPEG.zip"));
                var ent = zip.Entries.Where(x => x.Name == "ffmpeg.exe").First();
                ent.ExtractToFile(Path.Join(state.ExtraSettingsDataPath, "ffmpeg.exe"));
            }
        }
        if (!File.Exists(Path.Join(state.ExtraSettingsDataPath, "FaceFXWrapper.exe")))
        {
            DownloadFileAsync("https://github.com/Nukem9/FaceFXWrapper/releases/download/0.41/FaceFXWrapper.0.41.zip", Path.Join(state.ExtraSettingsDataPath, "tmp", "facefx.zip")).Wait();
            using var zip = ZipFile.OpenRead(Path.Join(state.ExtraSettingsDataPath, "tmp", "facefx.zip"));
            var ffxw = zip.Entries.Where(x => x.Name == "FaceFXWrapper.exe").First();
            ffxw.ExtractToFile(Path.Join(state.ExtraSettingsDataPath, "FaceFXWrapper.exe"));
        }
        if (!File.Exists("FonixData.cdf"))
        {
            File.Copy(Path.Join(CKTools, "LipGen", "LipGenerator", "FonixData.cdf"), "FonixData.cdf");
        }
        if (File.Exists(Path.Join(EDFP, "map.json")))
        {
            lines = JsonConvert.DeserializeObject<HashSet<LineTracker>>(File.ReadAllText(Path.Join(EDFP, "map.json")), settings) ?? [];
            var remc = lines.Where(x => x.variants.Count == 0).Count();
            Log($"Removing {remc} entries.", LogMode.NORMAL);
            lines.RemoveWhere(x => x.variants.Count == 0);
        }
        Directory.CreateDirectory($"{EDFP}/VGOutput/mp3/");
        Directory.CreateDirectory($"{EDFP}/VGOutput/wav/");
        Directory.CreateDirectory($"{EDFP}/VGOutput/wav/");
        Directory.CreateDirectory($"{EDFP}/VGOutput/lip/");
        Directory.CreateDirectory($"{EDFP}/VGOutput/xwm/");
        Directory.CreateDirectory($"{EDFP}/VGOutput/fuz/");
        client.DefaultRequestHeaders.Add("xi-api-key", APIInfo.key);
        client.BaseAddress = new Uri($"https://api.elevenlabs.io");
        foreach (var (Name, FormKey) in state.LoadOrder.PriorityOrder.DialogTopic().WinningOverrides().Where(x => $"{x.Name}" != x.EditorID && x.Category == DialogTopic.CategoryEnum.Topic).Where(x => !$"{x.Name}".IsNullOrEmpty() && $"{x.Name}" != $"{x.EditorID}").Select(x => (x.Name, x.FormKey)))
        {
            var line = lines.Where(x => x.forms.Contains(FormKey) || state.LinkCache.Resolve<IDialogTopicGetter>(FormKey).Name == Name).FirstOrDefault(new LineTracker
            {
                forms = [FormKey],
                variants = [],
            });
            var nam = $"{Name}";
            nam = REG.HiddenFN.Replace(nam, "").Trim();
            nam = REG.HiddenFN2.Replace(nam, "").Trim();
            if (nam.IsNullOrEmpty()) continue;
            //Basic Text Line
            if (!nam.Contains('<') && !nam.Contains('>') && !(nam.StartsWith('(') && nam.EndsWith(')')) && !(nam.StartsWith('[') && !nam.EndsWith(']')) && !(nam.EndsWith('*') && nam.StartsWith('*')) && !nam.Contains('_') && nam.Trim() != "..." && !nam.StartsWith('$'))
            {
                if(line.variants.Count > 0) {
                    line.forms.Add(FormKey);
                    Log($"Skipping {nam}", LogMode.NORMAL);
                    continue;
                }
                var dat = TryGen(nam);
                if (dat != null)
                {
                    line.variants.Add(new()
                    {
                        guid = dat.Value.guid,
                        splen = dat.Value.splen,
                        reg_frags = null,
                    });
                    lines.Add(line);
                }
            }
            //One of many different possible type variant data.
            else
            {
                if (nam.Trim() != "...")
                {
                    var cont = APIInfo.replacementLists.Where(x => nam.Contains($"<{x.Key}>")).ToDictionary();
                    foreach (var (vd, tline) in cont.GenerateTemplatedCartesianProduct(nam))
                    {
                        Log($"{tline}", LogMode.NORMAL);
                        if (!tline.Contains('<') && !tline.Contains('>') && !vd.All(x => line.variants.Any(y => y.reg_frags?.Contains(x) ?? false)))
                        {
                            var ld = TryGen(tline);
                            if (ld != null)
                            {
                                line.variants.Add(new()
                                {
                                    guid = ld.Value.guid,
                                    splen = ld.Value.splen,
                                    reg_frags = vd,
                                });
                                lines.Add(line);
                            }
                        }
                    }
                }
            }
        }
        {
            var remc = lines.Where(x => x.variants.Count == 0).Count();
            Log($"Removing {remc} Lines with no variants.", LogMode.NORMAL);
        }
        File.WriteAllText(Path.Join(EDFP, "map.json"), JsonConvert.SerializeObject(lines, settings));
        var files = lines.SelectMany(x => x.forms).Select(x => x.ModKey.ToString()).Distinct().ToHashSet();
        foreach (var fil in files)
        {
            Directory.CreateDirectory(Path.Join(state.DataFolderPath, "Sound", "VPC", "DefaultVoice", fil));
        }
        foreach (var line in lines)
        {
            foreach (var id in line.forms)
            {
                var jso = Path.Join(state.DataFolderPath, "Sound", "VPC", "DefaultVoice", id.ModKey.ToString(), $"{id.IDString()}.json");
                File.WriteAllText(jso, JsonConvert.SerializeObject(line.variants));
                foreach (var vd in line.variants)
                {
                    var fp = Path.Join(state.DataFolderPath, "Sound", "VPC", "DefaultVoice", id.ModKey.ToString(), $"{id.IDString()}-{vd.guid}.fuz");
                    File.Copy($"{EDFP}/VGOutput/fuz/{vd.guid}.fuz", fp, true);
                }
            }
        }
    }
    static LineData? TryGen(string text)
    {
        if (!APIInfo.dry_run)
        {
            try
            {
                return GenerateLive(text);
            }
            catch (Exception ex)
            {
                Log($"{ex.Message}", LogMode.NORMAL);
                APIInfo.dry_run = true;
                return null;
            }
        }
        else
        {
            GenerateDry(text);
            return null;
        }
    }

    static void Log(string lt, LogMode md)
    {
        if (APIInfo.log_mode >= md)
        {
            Console.WriteLine(lt);
        }
    }
    static void GenerateDry(string og_txt)
    {
        Log($"DRY {og_txt}", LogMode.NORMAL);
    }
    static LineData? GenerateLive(string text)
    {
        var guid = Guid.NewGuid().ToString().ToUpper();
        while (lines.Any(x => x.variants.Any(x => x.guid == $"{guid}")) || File.Exists(Path.Join(EDFP, "VGOutput", "fuz", $"{guid}.fuz")))
        {
            Console.WriteLine("Regenerating identical guid");
            guid = Guid.NewGuid().ToString().ToUpper();
        }
        var mp3name = Path.GetFullPath($"{EDFP}/VGOutput/mp3/{guid}.mp3");
        var wavname = Path.GetFullPath($"{EDFP}/VGOutput/wav/{guid}.wav");
        var rwavnam = Path.GetFullPath($"{EDFP}/VGOutput/wav/{guid}.resamp.wav");
        var lipname = Path.GetFullPath($"{EDFP}/VGOutput/lip/{guid}.lip");
        var xwmname = Path.GetFullPath($"{EDFP}/VGOutput/xwm/{guid}.xwm");
        var fuzname = Path.GetFullPath($"{EDFP}/VGOutput/fuz/{guid}.fuz");
        if (!File.Exists(mp3name) && !File.Exists(fuzname))
        {
            Log($"Generating: {text}", LogMode.NORMAL);
            StringContent stringContent = new(JsonConvert.SerializeObject(new Request(text, APIInfo)), Encoding.UTF8, "application/json");
            var cli = client.PostAsync($"/v1/text-to-speech/{APIInfo.voice_id}?output_format=mp3_44100_128", stringContent);
            cli.Wait();
            if (cli.Result.IsSuccessStatusCode)
            {
                var file = File.OpenWrite(mp3name);
                cli.Result.Content.CopyTo(file, null, CancellationToken.None);
                file.Close();
            }
            else
            {
                Log($"error: {cli.Result.StatusCode}", LogMode.NORMAL);
                throw new Exception("Out of requests");
            }
        }
        if (!File.Exists(fuzname) && File.Exists(mp3name))
        {
            LineData ret = new()
            {
                splen = Exts.GetMp3Duration(mp3name),
                guid = guid,
            };
            if (!File.Exists(wavname))
            {
                Process.Start($"{EDFP}/ffmpeg.exe", $"-i \"{mp3name}\" -ac 1 \"{wavname}\"").WaitForExit();
            }
            Process.Start($"{EDFP}/FaceFXWrapper.exe", $"Skyrim USEnglish FonixData.cdf \"{wavname}\" \"{rwavnam}\" \"{lipname}\" \"{text.Replace("\"", "\\\"")}\"").WaitForExit();
            Process.Start($"{EDFP}/xWMAEncode.exe", $"\"{wavname}\" \"{xwmname}\"").WaitForExit();
            Process.Start($"{EDFP}/BmlFuzEncode.exe", $"\"{fuzname}\" \"{xwmname}\" \"{lipname}\"").WaitForExit();
            Log($"Generated {text}", LogMode.NORMAL);
        }
        else
        {
            Log($"Skipping {text}", LogMode.NORMAL);
        }
        return null;
    }
}

public static partial class REG
{
    [GeneratedRegex("<([^=]*)=([^>]*)>")]
    private static partial Regex QuestAlias();
    public static Regex TextAliases => QuestAlias();
    [GeneratedRegex("(\\s?\\(.*\\)\\s?)")]
    private static partial Regex Hidden();
    public static Regex HiddenFN => Hidden();
    [GeneratedRegex("(\\s?\\[.*\\]\\s?)")]
    private static partial Regex Hidden2();
    public static Regex HiddenFN2 => Hidden2();
}