using CommandLine;
using DynamicData.Kernel;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Json;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Newtonsoft.Json;
using Noggog;
using Noggog.StructuredStrings;
using System.Data;
using System.Diagnostics;
using System.IO.Compression;
using System.Text;
using System.Text.RegularExpressions;

namespace SynPatcher;
public static class Program
{
    public static async Task DownloadFileAsync(string fileUrl, string destinationPath)
    {
        try
        {
            HttpClient dlclient = new();
            using var fileStream = new FileStream(destinationPath, FileMode.Create, FileAccess.Write, FileShare.None);
            var resp = await dlclient.GetStreamAsync(fileUrl);
            await resp.CopyToAsync(fileStream);
            Console.WriteLine($"Downloaded: {destinationPath}");
        }
        catch (HttpRequestException ex)
        {
            Console.WriteLine($"HTTP error: {ex.Message}");
        }
        catch (IOException ex)
        {
            Console.WriteLine($"File I/O error: {ex.Message}");
        }
    }
    static List<LineTracker> lines = [];
    static readonly HashSet<string> generatedText = [];
    static Lazy<ElevenLabs> api = new();
    public static ElevenLabs APIInfo => api.Value;
    static readonly HttpClient client = new();
    static string EDFP = string.Empty;
    static string CKTools = string.Empty;
    public static async Task<int> Main(string[] args)
    {
        return await SynthesisPipeline.Instance.SetAutogeneratedSettings("ElevenLabs", "elevenlabs.json", out api).SetTypicalOpen(GameRelease.SkyrimSE, "Labs.esp").AddPatch<ISkyrimMod, ISkyrimModGetter>(Patch).Run(args);
    }
    static void Patch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        JsonSerializerSettings settings = new();
        settings.AddMutagenConverters();
        settings.Formatting = Formatting.Indented;
        EDFP = state.ExtraSettingsDataPath ?? string.Empty;
        var parent = Directory.GetParent(state.DataFolderPath);
        CKTools = Path.Join(parent?.FullName, "Tools");
        Directory.CreateDirectory(Path.Join(state.ExtraSettingsDataPath, "tmp"));
        if (!File.Exists(Path.Join(state.ExtraSettingsDataPath, "ffmpeg.exe")))
        {
            if (!File.Exists(Path.Join(state.ExtraSettingsDataPath, "tmp", "FFMPEG.zip")))
            {
                DownloadFileAsync("https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-n7.1-latest-win64-gpl-7.1.zip", Path.Join(state.ExtraSettingsDataPath, "tmp", "FFMPEG.zip")).Wait();
                using var zip = ZipFile.OpenRead(Path.Join(state.ExtraSettingsDataPath, "tmp", "FFMPEG.zip"));
                var ent = zip.Entries.Where(x => x.Name == "ffmpeg.exe").First();
                ent.ExtractToFile(Path.Join(state.ExtraSettingsDataPath, "ffmpeg.exe"));
            }
        }
        if (!File.Exists(Path.Join(state.ExtraSettingsDataPath, "FaceFXWrapper.exe")))
        {
            DownloadFileAsync("https://github.com/Nukem9/FaceFXWrapper/releases/download/0.41/FaceFXWrapper.0.41.zip", Path.Join(state.ExtraSettingsDataPath, "tmp", "facefx.zip")).Wait();
            using var zip = ZipFile.OpenRead(Path.Join(state.ExtraSettingsDataPath, "tmp", "facefx.zip"));
            var ffxw = zip.Entries.Where(x => x.Name == "FaceFXWrapper.exe").First();
            ffxw.ExtractToFile(Path.Join(state.ExtraSettingsDataPath, "FaceFXWrapper.exe"));
        }
        if (!File.Exists("FonixData.cdf"))
        {
            File.Copy(Path.Join(CKTools, "LipGen", "LipGenerator", "FonixData.cdf"), "FonixData.cdf");
        }
        if (File.Exists(Path.Join(EDFP, "map.json")))
        {
            lines = JsonConvert.DeserializeObject<List<LineTracker>>(File.ReadAllText(Path.Join(EDFP, "map.json")), settings) ?? [];
        }
        Directory.CreateDirectory($"{EDFP}/VGOutput/mp3/");
        Directory.CreateDirectory($"{EDFP}/VGOutput/wav/");
        Directory.CreateDirectory($"{EDFP}/VGOutput/wav/");
        Directory.CreateDirectory($"{EDFP}/VGOutput/lip/");
        Directory.CreateDirectory($"{EDFP}/VGOutput/xwm/");
        Directory.CreateDirectory($"{EDFP}/VGOutput/fuz/");
        client.DefaultRequestHeaders.Add("xi-api-key", APIInfo.key);
        client.BaseAddress = new Uri($"https://api.elevenlabs.io");
        foreach (var (Name, FormKey) in state.LoadOrder.PriorityOrder.DialogTopic().WinningOverrides().Where(x => $"{x.Name}" != x.EditorID && x.Category == DialogTopic.CategoryEnum.Topic).Where(x => !$"{x.Name}".IsNullOrEmpty() && $"{x.Name}" != $"{x.EditorID}").Select(x => (x.Name, x.FormKey)))
        {
            var nam = Name?.String ?? "";
            nam = REG.HiddenFN.Replace(nam, "").Trim();
            nam = REG.HiddenFN2.Replace(nam, "").Trim();
            if (nam.IsNullOrEmpty()) continue;
            //Basic Text Line
            if (!nam.Contains('<') && !nam.Contains('>') && !(nam.StartsWith('(') && nam.EndsWith(')')) && !(nam.StartsWith('[') && !nam.EndsWith(']')) && !(nam.EndsWith('*') && nam.StartsWith('*')) && !nam.Contains('_') && nam.Trim() != "..." && !nam.StartsWith('$'))
            {
                var dat = TryGen(nam);
                if (dat != null)
                {
                    lines.Add(new()
                    {
                        forms = [FormKey],
                        variants = [
                            new() {
                                guid = dat.Value.guid,
                                splen = dat.Value.splen,
                                reg_frags = null,
                            }
                        ]
                    });
                }
            }
            //One of many different possible type variant data.
            else
            {
                if (nam.Trim() != "...")
                {
                    var varGuid = Guid.NewGuid().ToString().ToUpper();
                    while (lines.Any(x => x.variants.Any(x => x.guid == $"{varGuid}")) || File.Exists(Path.Join(EDFP, "VGOutput", "fuz", $"{varGuid}.fuz")))
                    {
                        Console.WriteLine("Regenerating identical guid");
                        varGuid = Guid.NewGuid().ToString().ToUpper();
                    }
                    var mtch = REG.TextAliases.Matches(nam);
                    if (mtch.All(x => x.Groups.Count >= 3))
                    {
                        Log($"{mtch}", LogMode.NORMAL);
                        Log($"Aliases\n{string.Join("\n", mtch.Select(x => $"\t{x.Groups[1].Value} = {x.Groups[2].Value}").ToHashSet())}", LogMode.NORMAL);
                        Log(nam, LogMode.NORMAL);
                    }
                    //Log($"SGen \"{nam}\"", LogMode.NORMAL);
                }
            }
        }
        File.WriteAllText(Path.Join(EDFP, "map.json"), JsonConvert.SerializeObject(lines, settings));
        foreach (var line in lines)
        {
            foreach (var id in line.forms)
            {
                var jso = Path.Join(state.DataFolderPath, "Sound", "VPC", "DefaultVoice", id.ModKey.ToString(), $"{id.IDString()}.json");
                File.WriteAllText(jso, JsonConvert.SerializeObject(line.variants));
                foreach (var vd in line.variants)
                {
                    var fp = Path.Join(state.DataFolderPath, "Sound", "VPC", "DefaultVoice", id.ModKey.ToString(), $"{id.IDString()}-{vd.guid}.fuz");
                    File.Copy($"{EDFP}/VGOutput/fuz/{vd.guid}.fuz", fp, true);
                }
            }
        }
    }

    static HashSet<VariantData> TryGenWithVData(IEnumerable<Dictionary<string, string>> replDicts, string textOLine)
    {
        HashSet<VariantData> variants = [];
        foreach (var repls in replDicts)
        {
            var ltext = textOLine;
            foreach (var rep in repls)
            {
                ltext = ltext.Replace(rep.Key, rep.Value);
            }
            var data = TryGen(ltext);
            if (data != null)
            {
                variants.Add(new VariantData()
                {
                    guid = data.Value.guid,
                    splen = data.Value.splen,
                    reg_frags = repls.Values,
                });
            }
        }
        return variants;
    }

    static LineData? TryGen(string text)
    {
        if (!APIInfo.dry_run)
        {
            try
            {
                return GenerateLive(text);
            }
            catch (Exception ex)
            {
                Log($"{ex.Message}", LogMode.NORMAL);
                APIInfo.dry_run = true;
                return null;
            }
        }
        else
        {
            GenerateDry(text);
            return null;
        }
    }

    static void Log(string lt, LogMode md)
    {
        if (APIInfo.log_mode >= md)
        {
            Console.WriteLine(lt);
        }
    }
    static void GenerateDry(string og_txt)
    {
        Log($"DRY {og_txt}", LogMode.DEBUG);
    }
    static LineData? GenerateLive(string text)
    {
        var guid = Guid.NewGuid().ToString().ToUpper();
        while (lines.Any(x => x.variants.Any(x => x.guid == $"{guid}")) || File.Exists(Path.Join(EDFP, "VGOutput", "fuz", $"{guid}.fuz")))
        {
            Console.WriteLine("Regenerating identical guid");
            guid = Guid.NewGuid().ToString().ToUpper();
        }
        var mp3name = Path.GetFullPath($"{EDFP}/VGOutput/mp3/{guid}.mp3");
        var wavname = Path.GetFullPath($"{EDFP}/VGOutput/wav/{guid}.wav");
        var rwavnam = Path.GetFullPath($"{EDFP}/VGOutput/wav/{guid}.resamp.wav");
        var lipname = Path.GetFullPath($"{EDFP}/VGOutput/lip/{guid}.lip");
        var xwmname = Path.GetFullPath($"{EDFP}/VGOutput/xwm/{guid}.xwm");
        var fuzname = Path.GetFullPath($"{EDFP}/VGOutput/fuz/{guid}.fuz");
        if (!File.Exists(mp3name) && !File.Exists(fuzname))
        {
            Log($"Generating: {text}", LogMode.NORMAL);
            StringContent stringContent = new(JsonConvert.SerializeObject(new Request(text, APIInfo)), Encoding.UTF8, "application/json");
            var cli = client.PostAsync($"/v1/text-to-speech/{APIInfo.voice_id}?output_format=mp3_44100_128", stringContent);
            cli.Wait();
            if (cli.Result.IsSuccessStatusCode)
            {
                var file = File.OpenWrite(mp3name);
                cli.Result.Content.CopyTo(file, null, CancellationToken.None);
                file.Close();
            }
            else
            {
                Log($"error: {cli.Result.StatusCode}", LogMode.NORMAL);
                throw new Exception("Out of requests");
            }
        }
        if (!File.Exists(fuzname) && File.Exists(mp3name))
        {
            LineData ret = new()
            {
                splen = Exts.GetMp3Duration(mp3name),
                guid = guid,
            };
            if (!File.Exists(wavname))
            {
                Process.Start($"{EDFP}/ffmpeg.exe", $"-i \"{mp3name}\" -ac 1 \"{wavname}\"").WaitForExit();
            }
            Process.Start($"{EDFP}/FaceFXWrapper.exe", $"Skyrim USEnglish FonixData.cdf \"{wavname}\" \"{rwavnam}\" \"{lipname}\" \"{text.Replace("\"", "\\\"")}\"").WaitForExit();
            Process.Start($"{EDFP}/xWMAEncode.exe", $"\"{wavname}\" \"{xwmname}\"").WaitForExit();
            Process.Start($"{EDFP}/BmlFuzEncode.exe", $"\"{fuzname}\" \"{xwmname}\" \"{lipname}\"").WaitForExit();
            Log($"Generated {text}", LogMode.NORMAL);
        }
        else
        {
            Log($"Skipping {text}", LogMode.NORMAL);
        }
        return null;
    }
}

public static partial class REG
{
    [GeneratedRegex("<([^=]*)=([^>]*)>")]
    private static partial Regex QuestAlias();
    public static Regex TextAliases => QuestAlias();
    [GeneratedRegex("(\\s?\\(.*\\)\\s?)")]
    private static partial Regex Hidden();
    public static Regex HiddenFN => Hidden();
    [GeneratedRegex("(\\s?\\[.*\\]\\s?)")]
    private static partial Regex Hidden2();
    public static Regex HiddenFN2 => Hidden2();
}